/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2019-2023 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

     ================================================================== */
#ifndef SGDMA_H_
#define SGDMA_H_

#include <linux/types.h>

/* Sgdma driver source code versions */
#define DRIVER_MAJOR_VERSION			1
#define DRIVER_MINOR_VERSION			0
#define DRIVER_TEST_VERSION				0

/* Register name, address and offset */
#define MM2S_CTRL					(0x00U)
#define MM2S_STS					(0x04U)
#define MM2S_CURDESC				(0x08U)
#define S2MM_CTRL					(0x20U)
#define S2MM_STS					(0x24U)
#define S2MM_CURDESC				(0x28U)

#define MAX_TRANSFER_SIZE			(0xffffU)
#define MULTI_BUF_SIZE				(100U)
#define FP_BIT_POSITION				(30U)
#define NXT_BIT_POSITION			(31U)
#define TID_BIT_POSITION			(20U)
#define TDEST_BIT_POSITION			(16U)
#define XFER_CMPL_POSITION			(16U)
#define DESC_SIZE					(0x10U)
#define BUFFER_SIZE_MASK			(0xffffU)
#define SGDMA_RESET_FLAG			(1U)
#define DMA_TRIGGER					(1U)
#define MSB_ADDR					(0x00U)
#define NXT_1						(1U)
#define	NXT_0						(0U)
#define FP_1						(1U)
#define FP_0						(0U)
#define XFER_CMPL_1					(0x01U)
#define IDX_0						(0U)
#define TRUE						(1U)
#define FALSE						(0U)
#define RET_FAILURE					(1U)
#define RET_SUCCESS					(0U)

#define IS_NULL						(0)

/*Enum*/
typedef enum
{
	MM2S_RESET = 0,
	S2MM_RESET = 0x20,
}control_type_t;

typedef enum
{
	MM2S_STATUS = 0x04,
	S2MM_STATUS = 0x24,
}status_type_t;

typedef enum
{
	UNMASK = 0,
	MASK,
}irq_mask_t;

typedef enum
{
	MM2S_CTRL_REG = 0,
	MM2S_STATUS_REG = 0x04,
	MM2S_CURDESC_REG = 0x08,
	S2MM_CTRL_REG = 0x20,
	S2MM_STATUS_REG = 0x24,
	S2MM_CURDESC_REG = 0x28,
}sgdma_reg_type_t;

/*------------------------------------------- structure and union ------------------------------------------------------*/

typedef struct {
	unsigned int base_addr;
	unsigned int *buffer;
	unsigned int num_of_desc;
	unsigned int blocking_s2mm;
	unsigned int blocking_mm2s;
	unsigned int mm2s_buffer_addr;
	unsigned int s2mm_buffer_addr;
	unsigned int mm2s_bd_addr;
	unsigned int s2mm_bd_addr;
	unsigned int per_desc_length;
}sgdma_instance_t;


/*mm2s control and status register structure */
typedef struct {
	volatile unsigned int mm_request : 1;
	volatile unsigned int mm_reset : 1;
	volatile unsigned int mm_rsvd_1 : 14;
	volatile unsigned int mm_cmpl_irq_mask : 1;
	volatile unsigned int mm_rsvd_2 : 15;
}mm2s_ctrl_reg_t;

typedef struct {
	volatile unsigned int mm_status : 1;
	volatile unsigned int mm_rsvd_1 : 7;
	volatile unsigned int mm_reg_bd_len_err : 1;
	volatile unsigned int mm_reg_axi_slave_err : 1;
	volatile unsigned int mm_reg_axi_desc_err : 1;
	volatile unsigned int mm_rsvd_2 : 5;
	volatile unsigned int mm_xfer_cmpl : 1;
	volatile unsigned int mm_xfer_err : 1;
	volatile unsigned int mm_rsvd_3 : 14;
}mm2s_sts_reg_t;

/* mm2s single and multi buffer Descriptor Structure */
typedef struct {
	volatile unsigned int mm_buffer_addr;	//Buffer addr
	volatile unsigned int mm_buffer_msb_addr;	//Buffer msb addr
	volatile unsigned int mm_control_buffer_size : 16;	//Control
	volatile unsigned int mm_control_tdest : 4;
	volatile unsigned int mm_control_tid : 4;
	volatile unsigned int mm_control_arprot : 3;
	volatile unsigned int mm_control_rsvd : 3;
	volatile unsigned int mm_control_fp : 1;
	volatile unsigned int mm_control_nxt : 1;
	volatile unsigned int mm_status_transffered_size : 16;	//Status
	volatile unsigned int mm_status_rsvd : 11;
	volatile unsigned int mm_status_axi_desc_err : 1;
	volatile unsigned int mm_status_axi_slave_err : 1;
	volatile unsigned int mm_status_transffered_len_err : 1;
	volatile unsigned int mm_status_bd_len_err : 1;
	volatile unsigned int mm_status_cmpl : 1;
}mm2s_desc_tx_t;

typedef struct{
	volatile unsigned int mm_buffer_addr;
	volatile unsigned int mm_buffer_msb_addr;
	volatile unsigned int mm_control;
	volatile unsigned int mm_status;
}mm2s_desc_tx_ext_t;

/*mm2s  union*/
typedef union
{
	mm2s_desc_tx_ext_t mm_bd_ext;
	mm2s_desc_tx_t mm_bd;
}mm2s_desc_t;

/* s2mm control and status register structure */
typedef struct {
	volatile unsigned int s_request : 1;
	volatile unsigned int s_reset : 1;
	volatile unsigned int s_rsvd_1 : 14;
	volatile unsigned int s_cmpl_irq_mask : 1;
	volatile unsigned int s_rsvd_2 : 15;
}s2mm_ctrl_reg_t;

typedef struct {
	volatile unsigned int s_status : 1;
	volatile unsigned int s_rsvd_1 : 7;
	volatile unsigned int s_reg_bd_len_err : 1;
	volatile unsigned int s_reg_axi_slave_err : 1;
	volatile unsigned int s_reg_axi_desc_err : 1;
	volatile unsigned int s_rsvd_2 : 5;
	volatile unsigned int s_xfer_cmpl : 1;
	volatile unsigned int s_xfer_err : 1;
	volatile unsigned int s_rsvd_3 : 14;
}s2mm_sts_reg_t;

/*s2mm single and multi buffer Descriptor Structure */
typedef struct {
	volatile unsigned int s_buffer_addr;	//Buffer addr
	volatile unsigned int s_buffer_msb_addr;	//Buffer msb addr
	volatile unsigned int s_control_buffer_size : 16;	//Control
	volatile unsigned int s_control_rsvd_1 : 8;
	volatile unsigned int s_control_awprot : 3;
	volatile unsigned int s_control_rsvd_2 : 4;
	volatile unsigned int s_control_nxt : 1;
	volatile unsigned int s_status_transffered_size : 16;	//Status
	volatile unsigned int s_status_rsvd : 11;
	volatile unsigned int s_status_axi_desc_err : 1;
	volatile unsigned int s_status_axi_slave_err : 1;
	volatile unsigned int s_status_transffered_len_err : 1;
	volatile unsigned int s_status_bd_len_err : 1;
	volatile unsigned int s_status_cmpl : 1;
}s2mm_desc_tx_t;

typedef struct{
	volatile unsigned int s_buffer_addr;
	volatile unsigned int s_buffer_msb_addr;
	volatile unsigned int s_control;
	volatile unsigned int s_status;
}s2mm_desc_tx_ext_t;

/*s2mm union */
typedef union
{
	s2mm_desc_tx_ext_t s_bd_ext;
	s2mm_desc_tx_t s_bd;
}s2mm_desc_t;

typedef struct {
	volatile unsigned int request : 1;
	volatile unsigned int reset : 1;
	volatile unsigned int rsvd_1 : 14;
	volatile unsigned int cmpl_irq_mask : 1;
	volatile unsigned int rsvd_2 : 15;
}sgdma_ctrl_reg_t;

typedef struct {
	volatile unsigned int status : 1;
	volatile unsigned int rsvd_1 : 7;
	volatile unsigned int reg_bd_len_err : 1;
	volatile unsigned int reg_axi_slave_err : 1;
	volatile unsigned int reg_axi_desc_err : 1;
	volatile unsigned int rsvd_2 : 5;
	volatile unsigned int xfer_cmpl : 1;
	volatile unsigned int xfer_err : 1;
	volatile unsigned int rsvd_3 : 14;
}sgdma_sts_reg_t;

/* --------------------------------------------------- Declaration ------------------------------------------------- */
void sgdma_init(sgdma_instance_t *this_sgdma, unsigned int base_addr, unsigned int num_of_desc);
void sgdma_reset(sgdma_instance_t *this_sgdma, control_type_t sgdma_cntl_type);
void sgdma_irq_mask(sgdma_instance_t *this_sgdma, control_type_t sgdma_cntl_type, irq_mask_t mask_value);
sgdma_sts_reg_t * get_sgdma_reg_status(sgdma_instance_t *this_sgdma, status_type_t sgdma_sts_type);
unsigned int get_mm2s_bd_status(int idx);
unsigned int get_s2mm_bd_status(int idx);
unsigned int mm2s_buf_desc_dma(sgdma_instance_t *this_sgdma);
unsigned int s2mm_buf_desc_dma(sgdma_instance_t *this_sgdma);
unsigned int sgdma_register_read(sgdma_instance_t *this_sgdma, sgdma_reg_type_t index, unsigned int *reg_data);
unsigned int sgdma_register_write(sgdma_instance_t *this_sgdma, sgdma_reg_type_t index, unsigned int reg_data);

/*
 * Explicit synchronization between writes to instruction memory and instruction fetches on the same
 * hart by flushing full instruction cache line.
 */
void cache_flush_ins(void);

/*
 * Invalidate 8-words(32-bytes) in data cache.
 * The starting address to be invalidate is aligned to 32-bytes boundary based on <addr>.
 * .e.g: 0x0 - 0x1c will be invalidate if addr=0x10, instead of invalidating 0x10-0x2c
 */
void cache_invalidate(uint32_t addr);

/*
 * Invalidate the whole data cache.
 */
void cache_invalidate_all(void);

#endif
