/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2019-2023 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

     ================================================================== */

#include "lattice_tse.h"
#include <lattice/lattice_sgdma.h>
#include <lattice/lattice_reg_access.h>
#include <dm.h>
#include <errno.h>
#include <fdt_support.h>
#include <log.h>
#include <memalign.h>
#include <miiphy.h>
#include <net.h>
#include <asm/cache.h>
#include <asm/global_data.h>
#include <linux/dma-mapping.h>
#include <asm/io.h>

struct lattice_tse_plat {
	const char *instance_name;
	unsigned int tse_base_address;
	unsigned int sgdma_base_address;
	unsigned int mm2s_bd_address;
	unsigned int mm2s_address;
	unsigned int s2mm_bd_address;
	unsigned int s2mm_address;
};

sgdma_instance_t sgdma_core;

/**
 * @brief This function is used to configure to receive all address frame and enabling
 * the tsemac at speed of 10/100/1000 Mbps.
 * @param : handle : handle for the tsemac.
 * @return : status for initialization
 */
unsigned char ethernet_init(tsemac_handle_t *handle)
{
	unsigned char status;
	if(handle->adr != ZERO)
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		tsemac->max_packet_size = MAX_PACKET_SIZE;		//configure maximum packet size register
		tsemac->ipg = IPG_TIME;
		tsemac->tx_rx_ctrl |= handle->tx_rx_ctrl_var;	//configure Rx MAC to receive multicast and broadcast frame receive
		ethernet_set_speed(handle);
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to transmit the frame by copying src_packet buffer into dest_packet
 * and same packet is transmit to tsemac.
 * @param : handle : handle for the tsemac.
 * 			src_packet : buffer containing the packet to transmit to tsemac.
 * 			dest_packet :src_packet to copy in dest_packet for user.
 * @return : void
 */
void ethernet_packet_handle(tsemac_handle_t *handle,unsigned int *src_packet,unsigned int *dest_packet)
{
	int count;
	for(count=ZERO;count<handle->frame_length;count++)
	{
		dest_packet[count] = src_packet[count];
	}
}

/**
 * @brief This function is used to set the mac address for tsemac.
 * @param: 	handle : handle for the tsemac.
 * @return: return the status of setting the MAC address.
 */
unsigned char ethernet_set_mac_address(tsemac_handle_t *handle)
{
	unsigned char status;
	if((handle->adr != ZERO) && (handle->mac_upper != ZERO) && (handle->mac_lower != ZERO))
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		tsemac->mac_addr0 = handle->mac_upper;						//storing the MAC address for first 4 byte in register MAC address0
		tsemac->mac_addr1 = handle->mac_lower;						//storing the MAC address for last 2 byte in register MAC address1
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to read the mac address for tsemac.
 * @param: 	handle : handle for the tsemac.
 * @retrun: return the status of MAC address read.
 */
unsigned char ethernet_get_mac_address(tsemac_handle_t *handle)
{
	unsigned char status;
	if(handle->adr != ZERO)
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		handle->mac_upper = tsemac->mac_addr0;							//read first 4 byte of MAC address from address word 0 register
		handle->mac_lower = tsemac->mac_addr1;							//read last 2 byte of MAC address from address word 1 register
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to set for multicast address for tsemac.
 * @param: 	handle : handle for the tsemac.
 * @retrun: return the status of setting the multicast address.
 */
unsigned char ethernet_set_multicast_address(tsemac_handle_t *handle)
{
	unsigned char status;
	if((handle->adr != ZERO) && (handle->multicast_upper != ZERO) && (handle->multicast_lower != ZERO))
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		tsemac->multi_cast0 = handle->multicast_upper;					//storing the first 4 byte of the 64 bit hash in mutlicast table word 0 register
		tsemac->multi_cast1 = handle->multicast_lower;					//storing the last 4 byte of the 64 bit hash in mutlicast table word 1 register
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to get for multicast address.
 * @param: 	handle : handle for the tsemac.
 * @retrun: return the status of multicast address read.
 */
unsigned char ethernet_get_multicast_address(tsemac_handle_t *handle)
{
	unsigned char status;
	if(handle->adr != ZERO)
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		handle->multicast_upper = tsemac->multi_cast0;						//read first 4 byte of the 64 bit hash from multicast table word 0 register
		handle->multicast_lower = tsemac->multi_cast1;						//read last 4 byte of the 64 bit hash from multicast table word 1 register
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to set the speed for tsemac at 10/100/1000 Mbps.
 * @param : handle : handle for the tsemac.
 * @return : return the success or failure status based on condition.
 */
unsigned char ethernet_set_speed(tsemac_handle_t *handle)
{
	unsigned char status;
	if(handle->adr != ZERO)
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		if(handle->speed_mode == one_g_mode)
		{
			tsemac->tx_rx_ctrl &= (~(ONE << SET_FULL_DUPLEX_MODE));    //set full duplex mode
			tsemac->mode_reg |= (ONE << SPEED_1G);					//set into 1G mode
		}
		else if(handle->speed_mode == fast_half_duplex_mode)
		{
			tsemac->tx_rx_ctrl |= (ONE << SET_HALF_DUPLEX_MODE);    //set half duplex mode
			tsemac->mode_reg &= (~(ONE << SPEED_10_OR_100_MBPS));	//set into 10 or 100 mbps
		}
		else
		{
			tsemac->tx_rx_ctrl &= (~(ONE << SET_FULL_DUPLEX_MODE));    //set full duplex mode
			tsemac->mode_reg &= (~(ONE << SPEED_10_OR_100_MBPS));	//set into 10 or 100 mbps
		}
		tsemac->mode_reg |= handle->enable_tx_mac | handle->enable_rx_mac;		//enable transmit and receive mode
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}
/**
 * @brief This function is used to read the statistics counter register.
 * @param: handle : handle for the tsemac.
 * 			stat_counter_reg_enum : enum for statistics counter register.
 * @return: total_count : return the total count after reading the statistics counter register.
 * Note : This API could not be tested due to IP limitation for Release 2023.2
 */
unsigned int ethernet_statistics_counter_register_read(tsemac_handle_t *handle,unsigned char stat_counter_reg_enum)
{
	unsigned int total_count;
	volatile unsigned int *counter_reg0 = (unsigned int *)(handle->adr + (stat_counter_reg_enum*FOUR));
	volatile unsigned int *counter_reg1 = (unsigned int *)(handle->adr + (stat_counter_reg_enum+ONE)*FOUR);
	total_count = (*counter_reg1 << SIXTEEN_BIT) | *counter_reg0;
	return total_count;
}
/**
 * @brief This function is used to read the Transmit and receive status register.
 * @param: handle : handle for the tsemac.
 * @return : return status register value after reading.
 */
unsigned int ethernet_tx_rx_status_reg_read(tsemac_handle_t *handle)
{
	tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
	return tsemac->tx_rx_status;
}
/**
 * @brief This function is used to read the mode register.
 * @param: handle : handle for the tsemac.
 * @return : return mode register value after reading.
 */
unsigned int ethernet_mode_reg_read(tsemac_handle_t *handle)
{
	tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
	return tsemac->mode_reg;
}
/**
 * @brief This function is used to set the particular bit in Transmit and Receive control register.
 * @param: handle : handle for the tsemac.
 * @return : return the success or failure status based on condition.
 */
unsigned char ethernet_tx_rx_control_reg_set(tsemac_handle_t *handle,unsigned char bit_pos)
{
	unsigned char status;
	if(handle->adr != ZERO)
	{
		tsemac_reg_type_t *tsemac = (tsemac_reg_type_t *) (handle->adr);
		tsemac->tx_rx_ctrl |= ONE << bit_pos;
		status = SUCCESS;
	}
	else
	{
		status = FAILURE;
	}
	return status;
}

static int lattice_tse_send(struct udevice *dev, void *packet, int length)
{
	int i, j = 0;
	unsigned int ret;
	unsigned int status = 0;
	unsigned int *write_packet = (unsigned int *)packet;
	struct lattice_tse_plat *plat = dev_get_plat(dev);

	for (i = 0; i <= length / 4; i++)
	{
		reg_32b_write((void *)((unsigned int)plat->mm2s_address + j), write_packet[i]);
		j += 4;
	}
	sgdma_core.base_addr = plat->sgdma_base_address;
	sgdma_core.buffer = (unsigned int *)plat->mm2s_address;
	sgdma_core.num_of_desc = 1;
	sgdma_core.blocking_mm2s = TRUE;
	sgdma_core.per_desc_length = length;

	ret = mm2s_buf_desc_dma(&sgdma_core);
	if (ret == FAILURE)
	{
		sgdma_reset(&sgdma_core, S2MM_RESET);
		printf("SGDMA write fail\r\n");
		return EIO;
	}
	else
	{
		status = get_mm2s_bd_status(0);
		if ((status & 0x80000000) == 0)
		{
			sgdma_reset(&sgdma_core, MM2S_RESET);
			printf("Failed: SGDMA write status = %08X\r\n", status);
			return EAGAIN;
		} else {
			printf("Success: SGDMA write status = %08X\r\n", status);
		}
		return 0;
	}
}


static int lattice_tse_recv(struct udevice *dev, int flags, uchar **packetp)
{
	uint32_t ret;
	unsigned short readbytes = 0;
	unsigned int status = 0;
	struct lattice_tse_plat *plat = dev_get_plat(dev);

	sgdma_core.buffer = (unsigned int *)plat->s2mm_address;
	sgdma_core.per_desc_length = 8192;

	ret = s2mm_buf_desc_dma(&sgdma_core);
	if (ret == FAILURE)
	{
		sgdma_reset(&sgdma_core, S2MM_RESET);
		printf("SGDMA read fail\r\n");
		readbytes = 0;
		return -EAGAIN;
	}
	else
	{
		status = get_s2mm_bd_status(0);
		if (((status & 0x20000000) != 0) || ((status & 0x2000FFFF) == 0))
		{
			printf("Failed: S2MM read status  = %08X\r\n",status);
			sgdma_reset(&sgdma_core, S2MM_RESET);
			readbytes = 0;
			return -EAGAIN;
		}
		else
		{
			readbytes = status & 0xFFFF;
			printf("Success: S2MM read status  = %08X, readbyte = %d\r\n",status, readbytes);
		}
	}
	printf("Dump received bytes:\n");
	for (int i = 0; i < readbytes/4; i++)
	{
		printf("0x%x ", sgdma_core.buffer[i]);
	}
	printf("\n");

	*packetp = memalign(ARCH_DMA_MINALIGN, MAX_PACKET_SIZE);
	if (*packetp == 0) {
		printf("%s: error allocating packetp\n", __func__);
		return -ENOMEM;
	}

	memcpy(*packetp, (char *)sgdma_core.buffer, readbytes);

	return readbytes;
}

static int lattice_tse_start(struct udevice *dev)
{
	static tsemac_handle_t tse_core;
	struct lattice_tse_plat *plat = dev_get_plat(dev);

	tse_core.adr = plat->tse_base_address;
	tse_core.speed_mode = one_g_mode;
	tse_core.tx_rx_ctrl_var = (RCV_SHORT_FRAME | RCV_PAUSE_FRAME | RCV_MULTICAST |
				   RCV_BROADCAST |
				   RCV_ALL_ADDR_FRAME);
	tse_core.enable_rx_mac = ENABLE_RX_MODE;
	tse_core.enable_tx_mac = ENABLE_TX_MODE;
	tse_core.mac_upper = 0x12EFCDAA;
	tse_core.mac_lower = 0x5634;
	if (ethernet_set_mac_address(&tse_core) != SUCCESS) return EIO;
	if (ethernet_init(&tse_core) != SUCCESS) return EAGAIN;

	sgdma_core.mm2s_bd_addr = plat->mm2s_bd_address;
	sgdma_core.s2mm_bd_addr = plat->s2mm_bd_address;
	sgdma_core.base_addr = plat->sgdma_base_address;
	sgdma_core.buffer = (unsigned int *)plat->s2mm_address;
	sgdma_core.num_of_desc = 1;
	sgdma_core.per_desc_length = 64;
	sgdma_core.blocking_s2mm = TRUE;
	sgdma_init(&sgdma_core, plat->sgdma_base_address, 1);

	return 0;
}

static int lattice_tse_free_pkt(struct udevice *dev, uchar *packet,
			       int length)
{
	// Suppose to free packet buffer after received packaget processed. TBD
	return 0;
}

static void lattice_tse_stop(struct udevice *dev)
{
	// Disable the hardware or reset.
	sgdma_reset(&sgdma_core, MM2S_RESET);
	sgdma_reset(&sgdma_core, S2MM_RESET);
	return;
}

static int lattice_tse_write_hwaddr(struct udevice *dev)
{
	// Need to mask out TX and RX operation flag to prevent MAC programming conflict
	static tsemac_handle_t tse_core;
	tse_core.mac_upper = 0x12EFCDAA;
	tse_core.mac_lower = 0x5634;
	ethernet_set_mac_address(&tse_core);
	return 0;
}

static const struct eth_ops lattice_tse_ops = {
	.start		= lattice_tse_start,
	.send		= lattice_tse_send,
	.recv		= lattice_tse_recv,
	.free_pkt	= lattice_tse_free_pkt,
	.stop		= lattice_tse_stop,
	.write_hwaddr	= lattice_tse_write_hwaddr,
};

static const struct udevice_id lattice_tse_ids[] = {
	{ .compatible = "lattice,lattice-tse-1.5.0"},
	{}
};

static int lattice_tse_probe(struct udevice *dev)
{
	struct lattice_tse_plat *plat = dev_get_plat(dev);
	fdt_addr_t base_addr;
	u32 sgdma_base_addr;
	u32 mm2s_address;
	u32 s2mm_address;
	u32 mm2s_bd_address;
	u32 s2mm_bd_address;

	base_addr = dev_read_addr(dev);
	if (base_addr == FDT_ADDR_T_NONE)
		return -EINVAL;
	plat->tse_base_address = base_addr;
	dev_read_u32(dev, "sgdma_base", &sgdma_base_addr);
	plat->sgdma_base_address = sgdma_base_addr;
	dev_read_u32(dev, "mm2s_address", &mm2s_address);
	plat->mm2s_address = mm2s_address;
	dev_read_u32(dev, "s2mm_address", &s2mm_address);
	plat->s2mm_address = s2mm_address;
	dev_read_u32(dev, "mm2s_bd_address", &mm2s_bd_address);
	plat->mm2s_bd_address = mm2s_bd_address;
	dev_read_u32(dev, "s2mm_bd_address", &s2mm_bd_address);
	plat->s2mm_bd_address = s2mm_bd_address;

	return 0;
}

U_BOOT_DRIVER(lattice_tse) = {
	.name	= "lattice_tse",
	.id	= UCLASS_ETH,
	.of_match = lattice_tse_ids,
	.ops	= &lattice_tse_ops,
	.plat_auto	= sizeof(struct lattice_tse_plat),
	.probe	= lattice_tse_probe,
};
